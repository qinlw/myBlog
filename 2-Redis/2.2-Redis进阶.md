# Redis进阶

[发布订阅模式](#发布订阅模式)

&emsp;&emsp;[核心概念](#核心概念)

&emsp;&emsp;[基本命令](#基本命令)

&emsp;&emsp;[工作机制](#工作机制)

[消息队列Stream](#消息队列Stream)

&emsp;&emsp;[核心特性](#核心特性)

&emsp;&emsp;[基础结构](#基础结构)

&emsp;&emsp;[常用命令](#常用命令)

&emsp;&emsp;[消费者组机制](#消费者组机制)

---

# 发布订阅模式

Redis的发布订阅（Pub/Sub）是一种消息传递机制，允许消息的发布者（Publisher）向频道发送消息，订阅者（Subscriber）监听特定频道接收消息，实现实时通信。

## 核心概念

- 发布者（Publisher）：通过 `publish` 命令向频道发送消息。
- 订阅者（Subscriber）：通过 `subscribe` 或 `psubscribe` 命令订阅一个或多个频道（支持通配符）。
- 频道（Channel）：消息传递的通道，发布者和订阅者通过频道名关联。

## 基本命令

- 订阅一个或多个频道，客户端进入订阅状态，等待接收消息。
	```
	subscribe channel [channel ...]
	```

- 使用通配符订阅频道

	语法 

		```
		psubscribe pattern [pattern ...]
		```

	使用示例：

		```
		psubscribe news.*	// 订阅所有以 "news." 开头的频道
		``` 

		```
		psubscribe chat.?   // 匹配单个字符，订阅如 "chat.8", "chat.k" 的频道
		```

- 向指定频道发送消息，返回接收到消息的订阅者数量。
	```
	publish channel message
	```

- 取消订阅指定频道，若无参数则退订所有频道。
	```
	unsubscribe [channel ...]
	```

- 取消通配符订阅。
	```
	punsubscribe [pattern ...]
	```

## 工作机制

- 订阅模式：客户端执行 `subscribe` 或 `psubscribe` 后，进入阻塞状态，仅能接收订阅相关消息。
- 消息分发：当发布者发送消息时，Redis 遍历所有订阅该频道的客户端，并推送消息。对于通配符订阅，检查频道是否匹配模式。
- 无持久化：消息是即时的，若订阅者不在线，消息会丢失。
- 单线程处理：Redis 单线程执行命令，确保消息顺序性，但高并发时可能影响性能。

# 消息队列Stream

Redis Stream 是 Redis 5.0 引入的一种高性能、持久化的消息队列数据结构

## 核心特性

- 消息持久化：Stream 的消息默认持久化存储，即使 Redis 重启也不会丢失（需配置持久化策略）。
- 多消费者组：支持多个消费者组独立消费同一 Stream，每个组维护自己的消费进度。
- 消息回溯：允许消费者重新读取历史消息（与发布/订阅不同，后者消息即发即失）。
- 阻塞读取：消费者可阻塞等待新消息，减少无效轮询。
- ACK 机制：消费者处理消息后需显式确认，未确认的消息可重新投递。

## 基础结构

- 消息格式：每个消息包含唯一递增的 ID（格式为<时间戳>-<序号>，如1680900030425-0）。
- 消息内容：键值对形式（类似 Hash），例如 {"name": "Alice", "action": "login"}。

## 常用命令

基本命令：

- 添加消息
	- 语法：

		```redis
		XADD stream_name ID field1 value1 [field2 value2 ...]
		```
	
		- stream_name：Stream 名称。
		- ID：指定生成消息ID，（如1620000000000-0，需要保证ID是递增的）， 也可使用 * 自动生成。

	- 示例：
 
		```redis
		xadd mystream * cnt one person joker  # 添加消息（*自动生成ID）
		```

- 查看Stream中消息的详细内容
	- 语法
		```redis  
		XRANGE stream_name start end COUNT count
		```
	
		- start、end: 起始及结束消息ID
		- COUNT count: 可选参数，限制返回的消息数量为count（默认返回所有匹配的消息）

	- 示例
		```redis
		xrange mys - + count 2
		```

- 查看Stream中消息的数量
	- 语法：

		```redis
		XLEN stream_name
		```
 
	- 示例：
	
		```redis
		xlen mys
		```

- 删除消息
	- 语法：

		```redis
		XDEL stream_name ID [ID ...]
		```
 
	- 示例：
	
		```redis
		xdel mys 1743772660924-0
		```

- 修剪消息队列长度
	- 语法：

		```redis
		XTRIM stream_key <MAXLEN|MINID> [=|~] threshold [LIMIT count]
		```

		- stream_key: Stream 的键名。
		- MAXLEN：保留最新的 N 条消息。
		- MINID：删除比指定 ID 旧的消息。
		- =：精确修剪（严格保留阈值数量）。
		- ~：近似修剪（性能更高，结果可能不精确）
		- threshold：
			- MAXLEN 对应保留的消息条数（如 1000）。
			- MINID 对应最小允许的 ID（如 1639382472915-0）。
		- LIMIT count: 可选参数，限制单次修剪的消息数量（用于分批次删除，避免阻塞）。

	- 示例：
	
		```redis
		xtrim mys maxlen = 2
		```

消费者相关：

- 消费者读取
	- 语法：

		```redis
		XREAD [COUNT count] [BLOCK milliseconds] STREAMS stream_name [stream_name ...] id [id ...]
		```

		- COUNT count：​可选参数，指定一次读取的最大消息数量。
		- BLOCK milliseconds：​可选参数，milliseconds是指定阻塞等待新消息的时间（毫秒）。设置为 0 表示无限期阻塞，直到有新消息到达。
		- STREAMS stream_name [stream_name ...]：​必选参数，stream_name是指定要读取的一个或多个流的名称。
		- ID [ID ...]：​必选参数，指定从哪个消息 ID 开始读取。使用特殊 ID $ 表示从最新的消息开始读取
 
	- 示例：
	
		```redis
		xread count 2 block 1000 streams mys 0 
		```

- 消费者组
	- 创建组
		- 语法：

			```redis
			XGROUP CREATE stream_name group_name id [MKSTREAM]
			```
	
			- group_name：消费者组的名称。
			- id：指定消费者组读取消息的起始 ID，通常使用 0 表示从流的最开始读取，使用 $ 表示从最新的消息开始读取。
			- MKSTREAM（可选）：如果指定的流不存在，Redis 会自动创建一个新的流。
		- 示例
			```redis
			xgroup CREATE mys g1 0
			```

	- 查看组
		- 语法
			```redis
			XINFO GROUPS stream_name				# 查看指定流的所有消费者组信息
			XINFO CONSUMERS stream_name group_name	# 查看指定消费者组的所有消费者的信息
			XINFO STREAM stream_name				# 查看指定流的详细信息，包括流的长度、消息数、消息的最大 ID 等
			```

	- 为消费者组创建新的消费者
		- 语法：
			```redis
			XGROUP CREATECONSUMER stream_name group_name consumer_name
			```

			- consumer_name：消费者名称

		- 示例：

			```redis
			xgroup createconsumer mys g1 consumer1
			```

	- 组内消费
		- 语法：
			```redis
			XREADGROUP GROUP group_name consumer_name [COUNT count] STREAMS stream_name ID
			```
			
		- 示例：
			```redis
			xreadgroup group g1 consumer1 count 2 block 1000 streams mys >
			```

			- '>' 表示从这个消息中读取最新的消息

## 消费者组机制
	
- 负载均衡：组内消费者自动分配消息，提高并发处理能力。
- 消息重新投递：若消息未确认（如消费者崩溃），可通过 XCLAIM 转移给其他消费者。
- Pending List：记录已读取但未确认的消息，可通过 XPENDING 监控。